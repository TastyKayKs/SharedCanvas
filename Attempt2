$Server = ""

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$HashTable = [HashTable]::Synchronized(@{})
$HashTable.Lines = @()
$HashTable.Hashes = [String[]]@()
$HashTable.Delta = $false

$Form = [System.Windows.Forms.Form]::new()
$Form.Text = "Shared Canvas"
$Form.MaximizeBox = $false
$Form.FormBorderStyle = [System.Windows.Forms.BorderStyle]::FixedSingle
$Form.StartPosition = [System.Windows.Forms.FormStartPosition]::Manual
$Form.Height = $Form.Width = 500
$Form.Left = $Form.Top = 0

$Color = [System.windows.Forms.Button]::new()
$Color.Text = "Color"
$Color.Width = 250
$Color.BackColor = [System.Drawing.Color]::Black
$Color.ForeColor = [System.Drawing.Color]::White
$Color.Add_Click({
    $ColorDialog = [System.Windows.Forms.ColorDialog]::new()
    $ColorDialog.ShowDialog()
    $C = $ColorDialog.Color
    
    $This.BackColor = $C
    
    $Lum = [Math]::Sqrt(
        $C.R * $C.R * 0.299 +
        $C.G * $C.G * 0.587 +
        $C.B * $C.B * 0.114
    )
    If($Lum -gt 130){
        $This.ForeColor = [System.Drawing.Color]::Black
    }Else{
        $This.ForeColor = [System.Drawing.Color]::White
    }
})
$Color.Parent = $Form

$Size = [System.Windows.Forms.NumericUpDown]::new()
$Size.Width = 245
$Size.Top = 2
$Size.Left = 250
$Size.Maximum = 100
$Size.Minimum = 1
$Size.Parent = $Form

$FreeDrawRunspace = [RunspaceFactory]::CreateRunspace()
$FreeDrawRunspace.Open()
$FreeDrawPosh = [Powershell]::Create()
$FreeDrawPosh.Runspace = $FreeDrawRunspace
[Void]$FreeDrawPosh.AddScript({
    param($F,$T)

    $F = $F.Value

    Try{
        Add-Type -Namespace "User" -Name "Keys" -MemberDefinition '
            [DllImport("user32.dll")]
            public static extern short GetKeyState(UInt16 virtualKeyCode);
        '
    }Catch{}

    $Jraphics = $F.CreateGraphics()

    $Pen = [System.Drawing.Pen]::new([System.Drawing.Color]::Black)

    $LastHash = $T
    While(!$F.IsDisposed){
        If($T.Delta){
            $Jraphics.Clear()
            $T.Lines | Sort {$_.TS} | %{
                $Jraphics.DrawLines($_.Pen,$_.Pts)
            }
            $T.Delta = $false
            [Console]::WriteLine("Draw")
        }

        $LastPos = [System.Windows.Forms.Cursor]::Position
        $LastPos.X-=$F.Left+4
        $LastPos.Y-=$F.Top+26

        $Points = [System.Drawing.Point[]]@()
        While([User.Keys]::GetKeyState(0x01) -lt 0){
            Sleep -Milliseconds 10
            $CurrPos = [System.Windows.Forms.Cursor]::Position
            $CurrPos.X-=$F.Left+4
            $CurrPos.Y-=$F.Top+26
            If($CurrPos.X -ne $LastPos.X -or $CurrPos.Y -ne $LastPos.Y){
                $Pen.Color = $F.Controls[0].BackColor
                $Pen.Width = $F.Controls[1].Value
                $Jraphics.DrawLine($Pen, $LastPos.X, $LastPos.Y, $CurrPos.X, $CurrPos.Y)
                $Points+=($LastPos)
                $Points+=($CurrPos)
            }
            Sleep -Milliseconds 10
            $LastPos = [System.Windows.Forms.Cursor]::Position
            $LastPos.X-=$F.Left+4
            $LastPos.Y-=$F.Top+26
            If($CurrPos.X -ne $LastPos.X -or $CurrPos.Y -ne $LastPos.Y){
                $Pen.Color = $F.Controls[0].BackColor
                $Pen.Width = $F.Controls[1].Value
                $Jraphics.DrawLine($Pen, $CurrPos.X, $CurrPos.Y, $LastPos.X, $LastPos.Y)
                $Points+=($CurrPos)
                $Points+=($LastPos)
            }
        }

        If($Points.Count){
            $TS = [datetime]::Now.ToFileTimeUtc()
            $T.Lines+=@{TS=$TS;Pen=$Pen;Pts=$Points}
            $T.Hashes+=($TS.ToString()+","+$Pen.Color.ToArgb().ToString()+","+$Pen.Width.ToString()+","+[String]::Join(",",$(ForEach($Pt in $Points){$Pt.X.ToString()+"."+$Pt.Y.ToString()})))
            $T.Delta = $true
        }
    }
})
[Void]$FreeDrawPosh.AddParameter('F',[ref]$Form)
[Void]$FreeDrawPosh.AddParameter('T',$HashTable)
$FreeDrawJob=$FreeDrawPosh.BeginInvoke()

#Start Job to accept tcp connections and append the lines received to drawing table (clear incoming?)
#Send out copy of lines (append to outgoing?)

$CommsRunspace = [RunspaceFactory]::CreateRunspace()
$CommsRunspace.Open()
$CommsPosh = [Powershell]::Create()
$CommsPosh.Runspace = $CommsRunspace
[Void]$CommsPosh.AddScript({
    param($F,$T,$S)
    
    $F = $F.Value
    If(!$S){
        $AsyncCallback = [System.AsyncCallback]{
            param($Result)
            
            $Client = $Srv.EndAcceptTcpClient($Result)
            $Stream = $Client.GetStream()

            $Buff = [Byte[]]::new(1024)
            While(!$F.IsDisposed -and $Client.Connected){
                If($T.Delta){
                    $OutObj = [String]::Join(";",$(ForEach($Hash in ($T.Hashes | Sort {[int64]$_.Split(",")[0]})){$Hash}))
                    $OutObj = [System.Text.Encoding]::UTF8.GetBytes($OutObj)
                
                    If($OutObj){
                        $Stream.Write([byte][char]"A", 0, 1)
                        $Stream.Write($OutObj, 0, $OutObj.Length)
                        $Stream.Write([byte][char]"Z", 0, 1)
                    }
                }
                
                If($Stream.DataAvailable){
                    $InObj = ""
                    While($Stream.DataAvailable){
                        $InCount = $Stream.Read($Buff, 0, 1024)
                        $InObj+=[System.Text.Encoding]::UTF8.GetString($Buff[0..($InCount-1)])
                        Sleep -Milliseconds 10
                    }
                    Try{
                        If($InObj -match "A" -and $InObj -match "Z"){
                            ForEach($Line in (($InObj.Split("Z") | Select -First 1).Split("A") | Select -Last 1).Split(";")){
                                If(!$T.Hashes.Contains($Line)){
                                    $SplitLine = $Line.Split(',')
                                    $Time = [int64]($SplitLine[0])
                                    $Color = [System.Drawing.Color]::FromArgb([int]($SplitLine[1]))
                                    $Pen = [System.Drawing.Pen]::new($Color)
                                    $Pen.Width = [Int]$SplitLine[2]
                                    $T.Lines+=@{TS=$Time;Pen=$Pen;Pts=[System.Drawing.Point[]]$(ForEach($Point in $SplitLine[3..($SplitLine.Count-1)]){$Coords = $Point.Split("."); [System.Drawing.Point]::new([int]$Coords[0],[int]$Coords[1])})}
                                    $T.Hashes+=$Line

                                    $T.Delta = $true
                                }
                            }
                        }
                    }Catch{
                        $InObj | Out-File C:\Temp\Badsrv.txt
                        $Error[0] | Out-String | Out-file -Append C:\Temp\asyncErr.txt
                    }
                }

                Sleep -Milliseconds 500
            }

            $Client.Close()
            $Client.Dispose()
        }
        $Srv = [System.Net.Sockets.TcpListener]::new("0.0.0.0", 42069)
        $Srv.Start()
        While(!$F.IsDisposed){
            If($Srv.Pending()){
                $Result = $Srv.BeginAcceptTcpClient($AsyncCallBack,$Srv)
            }
        }
        $Srv.Stop()
    }Else{

        $Client = [System.Net.Sockets.TcpClient]::New($S, 42069)
        $Stream = $Client.GetStream()

        $Buff = [Byte[]]::new(1024)
        While(!$F.IsDisposed -and $Client.Connected){
            If($T.Delta){
                $OutObj = [String]::Join(";",$(ForEach($Hash in ($T.Hashes | Sort {[int64]$_.Split(",")[0]})){$Hash}))
                $OutObj = [System.Text.Encoding]::UTF8.GetBytes($OutObj)
                
                If($OutObj){
                    $Stream.Write([byte][char]"A", 0, 1)
                    $Stream.Write($OutObj, 0, $OutObj.Length)
                    $Stream.Write([byte][char]"Z", 0, 1)
                }
            }

            If($Stream.DataAvailable){
                $InObj = ""
                While($Stream.DataAvailable){
                    $InCount = $Stream.Read($Buff, 0, 1024)
                    $InObj+=[System.Text.Encoding]::UTF8.GetString($Buff[0..($InCount-1)])
                    Sleep -Milliseconds 10
                }
                Try{
                    If($InObj -match "A" -and $InObj -match "Z"){
                        ForEach($Line in (($InObj.Split("Z") | Select -First 1).Split("A") | Select -Last 1).Split(";")){
                            If(!$T.Hashes.Contains($Line)){
                                $SplitLine = $Line.Split(',')
                                $Time = [int64]($SplitLine[0])
                                $Color = [System.Drawing.Color]::FromArgb([int]($SplitLine[1]))
                                $Pen = [System.Drawing.Pen]::new($Color)
                                $Pen.Width = [Int]$SplitLine[2]
                                $T.Lines+=@{TS=$Time;Pen=$Pen;Pts=[System.Drawing.Point[]]$(ForEach($Point in $SplitLine[3..($SplitLine.Count-1)]){$Coords = $Point.Split("."); [System.Drawing.Point]::new([int]$Coords[0],[int]$Coords[1])})}
                                $T.Hashes+=$Line

                                $T.Delta = $true
                            }
                        }
                    }
                }Catch{
                    $InObj | Out-File C:\Temp\Badcli.txt
                    $Error[0] | Out-String | Out-file -Append C:\Temp\asyncErr.txt
                }
            }

            Sleep -Milliseconds 500
        }

        $Client.Close()
        $Client.Dispose()
    }
})
[Void]$CommsPosh.AddParameter('F',[ref]$Form)
[Void]$CommsPosh.AddParameter('T',$HashTable)
[Void]$CommsPosh.AddParameter('S',$Server)
$CommsJob=$CommsPosh.BeginInvoke()

$Form.ShowDialog()
$Form.Dispose()

[Void]$FreeDrawPosh.EndInvoke($FreeDrawJob)
$FreeDrawRunspace.Close()

[Void]$CommsPosh.EndInvoke($CommsJob)
$CommsRunspace.Close()
